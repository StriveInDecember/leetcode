## 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 

- 常规思路
```text
找到每个节点的路径
路径对比，找到最深的相同的节点即为所求
```
```path
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        p_path = self.get_path(root, p)
        q_path = self.get_path(root, q)
        res = None
        for a, b in zip(p_path, q_path):
            if a == b:
                res = a
            else:
                break
        return res

    def get_path(self, root, node):
        path = list()
        cur = root
        while cur != node:
            path.append(cur)
            if cur.val < node.val:
                cur = cur.right
            else:
                cur = cur.left
        path.append(cur)
        return path
```

- 考虑二叉搜索树的性质
```text
如果两个节点的值都小于当前节点值，继续考虑左子树
如果两个节点的值都大于当前节点值，继续考虑右子树
如果一个大，一个小，说明已经找到公共祖先了
```
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        res = root
        while True:
            if p.val < res.val and q.val < res.val:
                res = res.left
            elif p.val > res.val and q.val > res.val:
                res = res.right
            else:
                break
        return res
```