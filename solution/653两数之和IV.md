## 653. 两数之和IV 

给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 

- 常规
```text
先遍历二叉搜索树数字
双指针判断能否取到目标值
```  
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root: return False
        self.record = list()
        self.inorder(root)
        l, r = 0, len(self.record) - 1
        while l < r:
            tmp = self.record[l] + self.record[r]
            if tmp < k:
                l += 1
            elif tmp > k:
                r -= 1
            else:
                return True
        return False

    def inorder(self, root):
        if not root: return
        self.inorder(root.left)
        self.record.append(root.val)
        self.inorder(root.right)
        return
```
- hashset
```text
建一个set,
如果给定目标值减去当前节点值，如果出现在set里，即存在；
如果没有出现在set里，就把当前节点值添加到set里
```
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        self.memo = set()
        return self.check(root, k)

    def check(self, root, target):
        if not root: return False
        if target - root.val in self.memo: return True
        self.memo.add(root.val)
        return self.check(root.left, target) or self.check(root.right, target)
```

- BFS + HASHSET
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root: return False
        memo = set()
        queue = [root]
        while queue:
            cur = queue.pop(0)
            if k - cur.val in memo:
                return True
            memo.add(cur.val)
            if cur.left: queue.append(cur.left)
            if cur.right: queue.append(cur.right)
        return False
```

